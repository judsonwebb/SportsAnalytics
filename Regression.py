"""
Sports Analytics
"""

import numeric
import codeskulptor
import urllib2
import comp140_module6 as sports

def read_matrix(filename):
    """
    Parse data at the input filename into a matrix.
    """
    ordered_data=[]
    url = codeskulptor.file2url(filename)
    netfile = urllib2.urlopen(url)
    for line in netfile.readlines():
        
        row=line.split(',')
        #Converts strings to usable floats.
        for each in range(len(row)):
            
            row[each] = row[each].strip()

            row[each] = float(row[each])
          
        ordered_data.append(row)
    
    return numeric.Matrix(ordered_data)

class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.
        """
        self._weights = weights

    def __str__(self):
        """
        Return weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.
        """
        return inputs*self._weights

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.
        """
        predictions = self.generate_predictions(inputs)
        shape = predictions.shape()
        expected=[]
        the_real=[]
        for each in range(shape[0]):
            expected.append(predictions[(each,0)])
            the_real.append(actual_result[(each,0)])             
        return mse(the_real,expected)

def mse(result, expected):
    """
    Calculates the mean squared error between the sequences 
    result and expected.
    """
    #Assumes result and expected are the same length.
    comp_sum=0
    for each in range(len(expected)):
        comp_sum+=((expected[each]-result[each])**2)/(1.0*len(expected))
    return comp_sum    
def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.
    """
    
    return LinearModel((((output_data.transpose()*input_data))*(((input_data.transpose()*input_data).inverse()))).transpose())
    
    

def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix such that:

    1) Mean-Squared error in predictions is small
    2) The weights vector is simple

    This is done using the LASSO method with lambda
    parameter param, calculated for the specified
    number of iterations.
    """
    weights = fit_least_squares(input_data,output_data).get_weights()
    cursor = 0
    while cursor<iterations:
        old_weights=weights.copy()
        for each in range(input_data.shape()[1]):
            distance= bajj(param,each,input_data)
            change= ajj(weights,input_data,output_data,each)
            weights[(each,0)]=soft_threshold(weights[(each,0)]+change,distance)
        if (((weights - old_weights)).abs()).summation()<.00001:
            break
        cursor+=1
    return LinearModel(weights)

def soft_threshold(value,distance):
    """
    Moves x closer to zero by the distance t
    """
    if value>distance:
        return value-distance
    if abs(value)<=distance:
        return 0
    if value<(0-distance):
        return value+distance
def ajj(weights, input_data, output_data,iter_value):
    """
    Computes a change value to update the weights Matrix
    """
  
    numerator= (input_data.transpose()*output_data)[(iter_value,0)]-(((input_data.transpose()*input_data).getrow(iter_value)*weights)[(0,0)])
    denominator = (input_data.transpose()*input_data)[(iter_value,iter_value)]
    return numerator/denominator
def bajj(param, iter_value, input_data):
    """
    Computes a distance value to update the weights Matrix
    """
    return param/(2.0*(input_data.transpose()*input_data)[(iter_value,iter_value)])


def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.
    """
 
    #Sets up data being used
    early_stats=read_matrix("comp140_analytics_baseball.txt")
    early_wins=read_matrix("comp140_analytics_wins.txt")
    modern_stats=read_matrix("comp140_analytics_baseball_test.txt")
    modern_wins=read_matrix("comp140_analytics_wins_test.txt")
    
    
    lse_model=fit_least_squares(early_stats,early_wins)
    lasso_model_a=fit_lasso(2000, iterations,early_stats,early_wins)
    lasso_model_b=fit_lasso(7000, iterations,early_stats,early_wins)
    lasso_model_c=fit_lasso(50000, iterations,early_stats,early_wins)
    
    sports.print_weights(lasso_model_a)
    print "1954-2000 Data Prediction Error"
    #Prints out 1954-2000 prediction error based on these models
    print "LSE Model"
    print lse_model.prediction_error(early_stats,early_wins)
    print "LASSO Model, Lambda = 2000"
    print lasso_model_a.prediction_error(early_stats,early_wins)
    print "LASSO Model, Lambda = 7000"
    print lasso_model_b.prediction_error(early_stats,early_wins)
    print "LASSO Model, Lambda = 50000"
    print lasso_model_c.prediction_error(early_stats,early_wins)
    
    print "2001-2012 Data Prediction Error"
    #Prints out 2001-2012 prediction error based on these models
    print "LSE Model"
    print lse_model.prediction_error(modern_stats,modern_wins)
    print "LASSO Model, Lambda = 2000"
    print lasso_model_a.prediction_error(modern_stats,modern_wins)
    print "LASSO Model, Lambda = 7000"
    print lasso_model_b.prediction_error(modern_stats,modern_wins)
    print "LASSO Model, Lambda = 50000"
    print lasso_model_c.prediction_error(modern_stats,modern_wins)
    
    
#run_experiment(500)
#Received Output:

#1954-2000 Data Prediction Error
#LSE Model
#93.7399686198
#LASSO Model, Lambda = 2000
#124.478829393
#LASSO Model, Lambda = 7000
#131.138684403
#LASSO Model, Lambda = 50000
#139.93154029
#2001-2012 Data Prediction Error
#LSE Model
#105.085529071
#LASSO Model, Lambda = 2000
#99.805693628
#LASSO Model, Lambda = 7000
#95.4418952917
#LASSO Model, Lambda = 50000
#92.8456084221
